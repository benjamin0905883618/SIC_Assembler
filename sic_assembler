#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXOP 27

char name[16];
FILE *f;
FILE *fobj;
FILE *intermediate_file;
FILE *listing_code;

char line[80];
char label[7];
char op[7];
char operand[10];
char new_operand[7];
int indexed = 0;

char prog_name[7];
int  start_addr = 0;
int  prog_len = 0;
char obj_line[70];
char obj_code[7];
int  locctr = 0;
int  textpos = 0;

const char a_start[] = "START";
const char a_end[] = "END";
const char a_byte[] = "BYTE";
const char a_word[] = "WORD";
const char a_resb[] = "RESB";
const char a_resw[] = "RESW";

const char optab[26][2][6] = {{"ADD", "18"}, {"AND", "40"}, {"COMP", "28"}, {"DIV", "24"}, {"J", "3C"}, {"JEQ", "30"}, {"JGT", "34"}, {"JLT", "38"}, {"JSUB", "48"}, {"LDA", "00"}, {"LDCH", "50"}, {"LDL", "08"}, {"LDX", "04"}, {"MUL", "20"}, {"OR", "44"}, {"RD", "D8"}, {"RSUB", "4C"}, {"STA", "0C"}, {"STCH", "54"}, {"STL", "14"}, {"STSW", "E8"}, {"STX", "10"}, {"SUB", "1C"}, {"TD", "E0"}, {"TIX", "2C"}, {"WD", "DC"}};
const char hex_c[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

//symbol table的一個節點
typedef struct sym_node {
    char l[7];
    int v;
    struct sym_node * next,* prev;

} symNODE;

symNODE *tail = NULL;
symNODE *symtab = NULL;
int flag = 1;

//插入一個節點到symbol table
symNODE* insert(char *s, int r) {
    if(flag == 1){
        symtab = (struct sym_node *)malloc(sizeof(struct sym_node));
        tail = (struct sym_node *)malloc(sizeof(struct sym_node));
        symtab->prev = NULL;
        symtab->next = tail;
        tail->prev = symtab;
        tail->next = NULL;
        sprintf(tail->l,"XXXXXXX");
        flag = 0;
    }
    symNODE *temp = NULL;
    temp = (struct sym_node *)malloc(sizeof(struct sym_node));
    strcpy(temp->l,s);
    temp->v = r;
    temp->next = symtab->next;
    temp->prev = symtab;
    temp->next->prev = temp;
    temp->prev->next = temp;
    return temp;
}

//搜尋symbol table的結點
symNODE* search(symNODE *t, char *s) {
    if( t ) {
        if (strcmp(s, t->l) == 0) {
            return t;
        } else {
            return search(t->next, s);
        }
    } else {
        return NULL;
    }
}

//搜尋symbol table的節點
symNODE* new_search( char *s) {
    int i;
    strcpy( new_operand, s );
    for (i=strlen(new_operand); i<6; i++) new_operand[i] = ' ';
    new_operand[6] = '\0';
    return search( symtab, new_operand );
}

//找opcode
char* lookup (char *s) {
    int i = 0;
    int nf = 1;
    while ((i < MAXOP) && (nf)) {
        if (strcmp(s, optab[i][0]) == 0) nf=0;
        else i++;
    }
    if (i >= MAXOP) return NULL;
    else return (char*)optab[i][1];
}

//回傳operand長度
int operand_len () {
    int i, l;
    l = strlen(operand);
    // for (i=0; i<l; i++) printf("operand[%d] = [%c].\n", i, operand[i]);
    if (operand[0] == 'C') l -= 3;
    else if (operand[0] == 'X') l = (l-3) / 2;
    // printf("find_length([%s] = %d.\n", operand, l);
    return l;
}

//讀一行指令
int readline(){
    int i, j, l, x;

    fgets(line, 80, f);
    l = strlen(line);
    if ((l>0) && (line[0]!='.')) {
       for (i = 0; i < 6; i++) {
           label[i] = line[i];
       }
       label[i] = '\0';
       while(line[i]==' ') i++;
       j = 0;
       while ((line[i]!=' ') && (line[i]!='\0') && (line[i]!='\n') && (i < l)) {
           op[j] = line[i];
           i++; j++;
       }
       op[j] = '\0';
       while(line[i]==' ') i++;
       j = 0;
       while ((line[i]!=' ') && (line[i]!='\0') && (line[i]!='\n') && (i < l)) {
           operand[j] = line[i];
           i++; j++;
       }
       operand[j] = '\0';
       indexed = 0; x = strlen(operand);
       if((x>2) && (operand[x-2]==',') && (operand[x-1]=='X')) {
           operand[x-2] = '\0';
           indexed = 1;
       }
       printf("[%6X] Read a line: label=[%s], op=[%s], operand=[%s].\n",
           locctr, label, op, operand);
       return 1;
    } else {
       return 0;
    }
}

void write_line(FILE* F){
    line[0] = '\0';
    char str[6];
    sprintf(str,"%X",locctr);
    strcat(line,str);
    strcat(line," ");
    strcat(line,label);
    strcat(line," ");
    strcat(line,op);
    strcat(line," ");
    strcat(line,operand);
    //printf("%s\n",operand);
    strcat(line,"\n");
    //printf("%s",line);
    fprintf(F,"%s",line);
}

void pass1 () {
//
// Write your own pass1()
//
    readline();
    intermediate_file = fopen("loc.txt","w");
    if(strcmp(op,a_start) == 0){
        sscanf(operand,"%x",&start_addr);
        sscanf(operand,"%x",&locctr);
        write_line(intermediate_file);
        insert(label,locctr);
    }
    else
        locctr = 0;
    while(1){
        if(readline() == 1){
            if(strcmp(label,"      ") != 0){
                if( new_search(label)){
                    printf("error : duplicate symbol!\n");
                    break;
                }
                else
                    insert(label,locctr);
            }

            if(lookup(op) != NULL){
                locctr += 3;

            }
            else if(strcmp(op,a_end) == 0)
                break;
            else if(strcmp(op,a_word) == 0)
                locctr += 3;
            else if(strcmp(op,a_resw) == 0)
                locctr += 3 * atoi(operand);
            else if(strcmp(op,a_resb) == 0)
                locctr += atoi(operand);
            else if(strcmp(op,a_byte) == 0)
                locctr += operand_len(operand);
            else{
                printf("error : invalid operation code !");
                break;
            }
            write_line(intermediate_file);

        }

    }
    write_line(intermediate_file);
    fclose(intermediate_file);
    prog_len = locctr - start_addr;

}

//輸出synbol table
void print_symtab (symNODE * t) {
    if (t && strcmp(t->l,"XXXXXXX") != 0) {
        print_symtab( t->next );
        printf("[%s] = [%5X]\n", t->l, t->v);
    }
}

//初始化object code line
void init_obj_line () {
    int i;
    for (i=0; i<70; i++)
        obj_line[i] = ' ';
    obj_line[i] = '\0';
}

//寫header record
void wr_header () {
//
// Write your own wr_header()
//
    init_obj_line();
    strcat(obj_line,"H");
    strcat(obj_line,label);
    char str[6];
    sprintf(str,"%X",start_addr);
    strcat(obj_line,str);
    sprintf(str,"%X",prog_len);
    strcat(obj_line,str);
    fprintf(listing_code,("%s\n",obj_line));
    //length of object program in bytes(hex);
}

//初始object code
void init_obj_code () {
    for (int i=0; i<6; i++) obj_code[i] = ' ';
    obj_code[6] = '\0';
}


void conv_byte ( int l, char *p, char *q ) {
    int i, j, k, max, c, m, n;
    if (p[0] == 'X') {
        max = 2 * l;
        for (i=2, j=0, k=0; k < max; i++, j++, k++) q[j] = p[i];
        q[j] = '\0';
    }
    else if (p[0] == 'C') {
        max = l;
        for (i=2, j=0, k=0; k < max; i++, k++) {
            c = (int)p[i];
            m = c / 16;
            q[j++] = hex_c[m];
            n = c % 16;
            q[j++] = hex_c[n];
        }
        q[j] = '\0';
    }
    else {
        printf("Error: wrong operand of BYTE!\n");
    }
}

//初始text record
void init_text () {
    init_obj_line();
    sprintf( obj_line, "T%6X  ", locctr );
    for (int i=1; i<7; i++)
        if (obj_line[i] == ' ') obj_line[i] = '0';
    textpos = 9;
}

//寫入text record
void wr_text () {
//
// Write your own wr_text()
//
    printf("%S",obj_line);
}

//
void add_text ( int n, char *p ) {
    int const max = 69;
    int k = n * 2;
    int i;
    if ((textpos+k) > max) {
        wr_text();
        init_text();
    }
    for (i=0; i<k; i++) obj_line[textpos++] = p[i];
}

//寫入end record
void wr_end () {
//
// Write your own wr_end()
//
    printf("E%5X",start_addr);
}

int readline_obj(){
    int i, j, l, x;

    fgets(line, 80, f);
    l = strlen(line);
    char strlocctr[6];
    if ((l>0) && (line[0]!='.')) {
       for (i = 0; i < 5; i++) {
           strlocctr[i] = line[i];
       }
       sscanf(strlocctr,"%X",&locctr);
       j = 0;
       for (i = 5; i < 11; i++) {
           label[j] = line[i];
           j++;
       }
       label[i] = '\0';
       while(line[i]==' ') i++;
       j = 0;
       while ((line[i]!=' ') && (line[i]!='\0') && (line[i]!='\n') && (i < l)) {
           op[j] = line[i];
           i++; j++;
       }
       op[j] = '\0';
       while(line[i]==' ') i++;
       j = 0;
       while ((line[i]!=' ') && (line[i]!='\0') && (line[i]!='\n') && (i < l)) {
           operand[j] = line[i];
           i++; j++;
       }
       operand[j] = '\0';
       indexed = 0; x = strlen(operand);
       if((x>2) && (operand[x-2]==',') && (operand[x-1]=='X')) {
           operand[x-2] = '\0';
           indexed = 1;
       }
       printf("[%6X] Read a line: label=[%s], op=[%s], operand=[%s].\n",
           locctr, label, op, operand);
       return 1;
    } else {
       return 0;
    }
}

void write_line_obj(){
    line[0] = '\0';
    char str[6];
    sprintf(str,"%X",locctr);
    strcat(line,str);
    strcat(line," ");
    strcat(line,label);
    strcat(line," ");
    strcat(line,op);
    strcat(line," ");
    strcat(line,operand);
    strcat(line," ");
    strcat(line,obj_code);
    strcat(line,"\n");
    int len = strlen(line);
    line[len] = '\0';
    printf("%s",line);
    printf("%d",strlen(line));
    fprintf(listing_code,"%s",line);
    printf("Write Line OK!");
}

void pass2 () {
//
// Write your own pass2()
//

    readline_obj();
    listing_code = fopen("objcode.txt","w");
    if(strcmp(op,a_start) == 0){
        write_line_obj();
    }
    //wr_header();
    while(1){
        readline_obj();
        if(lookup(op) != NULL){
            init_obj_code();
            strcat(obj_code,lookup(op));
            if(new_search(operand) != NULL){
                char stroperand[10];
                sprintf(stroperand,"%X",new_search(operand)->v);
                strcat(obj_code,stroperand);
                printf("%s\n",obj_code);
            }
            else if(strcmp(operand,"") == 0){
                strcat(obj_code,"0000");
                printf("%s\n",obj_code);
            }
            else if(new_search(operand) == NULL)
            {
                printf("error : undefined symbol!");
                break;
            }

        }
        else if(strcmp(op,a_end) == 0)
            break;
        else if(strcmp(op,a_byte) == 0){
            init_obj_code();
            //printf("%d\n",operand_len(operand));
            conv_byte(operand_len(operand),operand,obj_code);
            printf("%s\n",obj_code);
        }
        else if(strcmp(op,a_word) == 0){
            init_obj_code();
            int temp = 0;
            char str[6];
            sscanf(operand,"%d",&temp);
            sprintf(obj_code,"%.6X",temp);
            printf("%s\n",obj_code);
        }
        write_line_obj();
        //printf("write_line successful");

    //add_text(operand_len(),obj_code);
    }
    write_line_obj();
    //fclose(listing_code);
    //add_text(operand_len(),obj_code);
    //wr_end();
}


int main(int argc, char*argv[]){
    argc = 2;
    int t = argc;
    argv[1] = "C:\\Users\\徐邦傑\\Desktop\\HW01\\test.sic";
    char fname[100];
    int i = 0;
    if (t == 2 ) {
        f = fopen(argv[1], "r");
        if (f) {
            printf("... Assembling %s!\n", argv[1]);
            pass1();
            printf("...... End of Pass 1; Program length = %6X.\n", prog_len);
            wr_header();
            printf("...... Contents in SymbTab:\n");
            print_symtab( symtab->next );
            fclose( f );
            strcpy( fname, argv[1] );
            //printf("%s\n",fname);
            for (i=0; (fname[i]!='.') && (fname[i]!='\0'); i++);
            fname[i++] = '.';
            fname[i++] = 'o';
            fname[i++] = 'b';
            fname[i++] = 'j';
            fname[i] = '\0';
            argv[2] = "C:\\Users\\徐邦傑\\Desktop\\HW01\\loc.txt";
            f = fopen(argv[2], "r");
            fobj = fopen(fname, "w");
            printf("...... Start of Pass 2.\n");
            pass2();
	    printf("Assembling succeeded.  %s is generated.\n", fname);
	    fclose( f );
	    fclose( fobj );
        } else {
            printf("Assemble syntax: [assemble soure_file_name]\n");
        } // f
    } else {
        printf("Assemble syntax: [assemble soure_file_name]\n");
    } // t
}
